#!/usr/bin/env bash

#setup
test -d /root/cptechs || mkdir /root/cptechs;
ticket="${PS1//[^0-9]/}";
if [ ! -z "$ticket" ]; then export ticket="$ticket"; mkdir /root/cptechs/"$ticket"; else >&2 printf "ticket not found in prompt\n"; fi

#colors
ESC_SEQ="\x1b["
COL_RESET=$ESC_SEQ"39;49;00m"
COL_RED=$ESC_SEQ"31;01m"
COL_GREEN=$ESC_SEQ"32;01m"
COL_YELLOW=$ESC_SEQ"33;01m"

#aliases
which vim >/dev/null 2>&1 && alias vless='vim -R --cmd "autocmd BufRead,BufNewFile *.strace set filetype=strace"';
[ -f /usr/local/cpanel/3rdparty/bin/sqlite3 ] && alias sqlite='/usr/local/cpanel/3rdparty/bin/sqlite3';
[ -f /usr/local/cpanel/3rdparty/bin/perl ] && { \
        alias acctinfo='/usr/local/cpanel/3rdparty/bin/perl <(curl -s "https://raw.githubusercontent.com/cPanelPeter/acctinfo/master/acctinfo")';
        alias chkservderrors='/usr/local/cpanel/3rdparty/bin/perl <(curl -s "https://raw.githubusercontent.com/cPanelTechs/TechScripts/master/chkservd_errors.pl")'; };

#functions
function upcp () {
  function halp () {
    cat <<'EOF' >&2
This function serves as a wrapper to `/scripts/upcp' to ensure `/etc/cpupdate.conf' is respected.
It also provides basic upcp/version infomration.

  -a    print all(current version/tier, available tier)
  -c    check for update
  -h    print this help
  -f    follow log with tail
  -r    check for running update
  -s    print update summary
  -S    printf update summary for major updates only
  -t    print public tiers
  -u    update cPanel respecting cpupdate.conf
  -v    print current cPanel version

EOF
  }
  function running () {
    if [ -e /usr/local/cpanel/upgrade_in_progress.txt ]; then
      printf "%b" "$COL_RED";
      printf "Found upcp touch file\n";
      printf "%b" "$COL_RESET";
      stat /usr/local/cpanel/upgrade_in_progress.txt;
    else
      printf "%b" "$COL_GREEN";
      printf "No upcp touch file\n";
      printf "%b" "$COL_RESET";
    fi;
    if [ -e /run/upcp.pid ]; then
      printf "%b" "$COL_RED";
      printf "Found upcp touch file\n";
      printf "%b" "$COL_RESET";
      stat /run/upcp.pid;
    else
      printf "%b" "$COL_GREEN";
      printf "No upcp touch file\n";
      printf "%b" "$COL_RESET";
    fi
    if ps aux|grep -q 'root.*cPanel.*Update.*[u]pcp'; then
      printf "%b" "$COL_RED";
      printf "Found upcp process:\n";
      printf "%b" "$COL_RESET";
      ps aux|grep 'root.*cPanel.*Update.*[u]pcp';
    else
      printf "%b" "$COL_GREEN";
      printf "No upcp process found\n";
      printf "%b" "$COL_RESET";
    fi;
  };
  OPTIND=1;
  while getopts "achrsStvuf" opt; do
    case "$opt" in
      a)
        awk -F'=' '/^CPANEL=/{tier=$2}/^RPMUP=/{rpm=$2}/^UPDATES=/{up=$2}END{print tier,rpm,up}' /etc/cpupdate.conf|while read -r tier rpm up; do
          printf "cPanel: %s\n" "$(cat /usr/local/cpanel/version)";
          printf "Tier: %s\n" "$tier";
          printf "cP updates: %s\n" "$up";
          printf "RPM updates: %s\n\n" "$rpm";
          printf "Public Tiers...\n";
          done;
          whmapi1 get_available_tiers|awk '/current:/{cur=$(NF-1)" "$NF}/edge:/{edg=$(NF-1)" "$NF}/release:/{rel=$(NF-1)" "$NF}/stable:/{stb=$(NF-1)" "$NF}END{printf stb"\n"rel"\n"cur"\n"edg"\n\n"}';
          running;
        ;;
      c)
        ver="$(cat /usr/local/cpanel/version)";
        tier="$(grep -oP '(?<=^CPANEL=).+' /etc/cpupdate.conf)";
        targ="$(whmapi1 get_available_tiers|grep -oP "(?<=$tier: ).+")";
        up="$(grep -oP '(?<=^UPDATES=).+' /etc/cpupdate.conf)";
        if [ "$ver" == "$targ" ]; then
          printf "%b" "$COL_GREEN";
          printf "cPanel is up-to-date!\n";
          printf "%b" "$COL_RESET";
          printf "Current version/tier: %s/%s\nTarget: %s\n" "$ver" "$tier" "$targ";
        else
          printf "%b" "$COL_RED";
          printf "Update Available!!\n";
          printf "%b" "$COL_RESET";
          printf "Current version/tier: %s/%s\nTarget: %s\n" "$ver" "$tier" "$targ";
        fi;
        ;;
      h)
        halp;
        ;;
      r)
        running;
        ;;
      s)
        awk '{if ($(NF-2)!=$NF)print}' /var/cpanel/updatelogs/summary.log;
        ;;
      S)
        awk -F'.' '{if ($2!=$5) print}' /var/cpanel/updatelogs/summary.log;
        ;;
      t)
        whmapi1 get_available_tiers|awk '/current:/{cur=$(NF-1)" "$NF}/edge:/{edg=$(NF-1)" "$NF}/release:/{rel=$(NF-1)" "$NF}/stable:/{stb=$(NF-1)" "$NF}END{printf stb"\n"rel"\n"cur"\n"edg"\n"}';
        ;;
      f)
        follow=1;
        ;;
      u)
        ver="$(cat /usr/local/cpanel/version)";
        tier="$(grep -oP '(?<=^CPANEL=).+' /etc/cpupdate.conf)";
        targ="$(whmapi1 get_available_tiers|grep -oP "(?<=$tier: ).+")";
        up="$(grep -oP '(?<=^UPDATES=).+' /etc/cpupdate.conf)";
        if [ "$ver" == "$targ" ]; then
          printf "Current version/tier: %s/%s\nTarget: %s\n" "$ver" "$tier" "$targ";
          if [ "$follow" -eq 1 ]; then
              /scripts/upcp --bg 2>&1|grep -oP '/var/cpanel/updatelogs/update\.[0-9]+\.log'|xargs tail -f;
            else
              /scripts/upcp --bg;
          fi;
        elif [ "$up" == manual ]; then
          printf "%b" "$COL_RED";
          printf "[WARN] Updates set to manual!!\n";
          printf "[WARN] Update will result in version change!!\n"
          printf "%b" "$COL_RESET";
          printf "Current version/tier: %s/%s\nTarget: %s\n" "$ver" "$tier" "$targ";
          printf "Are you sure you would like to continue?: [y/n]\n";
          read -r ans;
          if [[ "$ans" =~ [yY] ]]; then
            if [ "$follow" -eq 1 ]; then
              /scripts/upcp --bg 2>&1|grep -oP '/var/cpanel/updatelogs/update\.[0-9]+\.log'|xargs tail -f;
            else
              /scripts/upcp --bg;
            fi;
          else
            printf "Bailing out...\n";
          fi;
        else
          if [ "$follow" -eq 1 ]; then
            /scripts/upcp --bg 2>&1|grep -oP '/var/cpanel/updatelogs/update\.[0-9]+\.log'|xargs tail -f;
          else
            /scripts/upcp --bg;
          fi;
        fi;
        ;;
      v)
        cat /usr/local/cpanel/version;
        ;;
      \?)
        halp;
    esac;
  done;
  unset halp opt follow ver tier targ up ans OPTIND running;
}

function backuperrors () {
  for log in /usr/local/cpanel/logs/cpbackup/*; do
    printf -- "------------------------------\n%s:\n" "$log";
    while read err; do
      grep "$err" "$log";
    done <<EOF
Unable to get user id
Unable to load cPanel user data
You cannot copy the root user
pkgacct failed to copy daily backup
Could not use daily backup
Bailing out
The REMOTE_PASSWORD variable is missing
Unable to find domain name
Exiting with error code
Could not remove directory
Hook denied execution of pkgacct
Could not open
Could not chmod
Could not rename
failed to create the working dir
Unable to fork
Unable to waitpid
Unable to open
Failure dumping
Unable to read
does not appear to be valid XML
Could not create directory
mysqldump: Got error
mysqldump failed
EOF
  done;
  unset log err;
}

function genpass () {
  local pass;
  pass="$(openssl rand -base64 32)";
  printf "%s" "${pass//[\+=\/]/}";
};

function phpinfo () {
  if [[ "$#" -eq 0 ]]; then
    cwd="$(pwd)";
    if [[ "$cwd" =~ ^/home.?/.+ ]]; then
      _user="$(awk -F'/' '{print$3}' <<<"$cwd")";
      if [ ! -f "$cwd"/phpinfo.php ]; then
        printf 'Creating %s/phpinfo.php... ' "$cwd";
        printf '<?php phpinfo(); ?>\n' >> "$cwd"/phpinfo.php;
        printf "chown'ing... ";
        chown "$_user". "$cwd"/phpinfo.php;
        printf "Done: %s/phpinfo.php\n" "$cwd";
      else
        printf "%s/phpinfo.php already exists!\n" "$cwd";
        \ls -lah "$cwd"/phpinfo.php;
      fi;
    else
      printf "CWD doesn't appear valid: %s\n" "$cwd";
    fi;
    unset cwd _user;
  elif [[ "$#" -eq 1 ]]; then
    if [[ "$1" == -p ]]; then
      printf '<?php phpinfo(); ?>\n';
    fi;
  elif  [[ "$#" -gt 1 ]]; then
    if [[ "$1" == -d ]]; then
      local dom;
      for dom in "${@:2}"; do
        if [[ "$dom" =~ .+\..+ ]]; then
          doc="$(awk -F':' -v var=${dom} '$1==var{split($2,path,"=="); print path[5]}' /etc/userdatadomains)";
          _user="$(awk -F'[: =]' -v var="$dom" '$1==var{print$3}' /etc/userdatadomains)";
          if [[ ! "${doc:=null}" == null ]]; then
            if [ ! -f "$doc"/phpinfo.php ]; then
              printf 'Creating %s/phpinfo.php... ' "$doc";
              printf '<?php phpinfo(); ?>\n' >> "$doc"/phpinfo.php;
              printf "chown'ing... ";
              chown "$_user". "$doc"/phpinfo.php;
              printf "Done: %s/phpinfo.php\n" "$doc";
            else
              printf "%s/phpinfo.php already exists!\n" "$doc";
              \ls -lah "$doc"/phpinfo.php;
            fi;
          else
            printf "Couldn't find %s in /etc/userdatadomains\n" "$dom";
          fi
        else
          printf "%s is not a valid domain\n" "$dom";
        fi;
      done;
    fi;
  else
    printf "Unrecognized arg\n";
  fi;
};

function lst () {
  if [[ "$#" -eq 0 ]]; then
    local cwd;
    cwd="$(pwd)";
    for each in ${cwd//\// }; do
      full+="/$each";
      \stat -c '%a %U:%G(%u:%g) %F %n' "$full";
    done;
    unset full each;
  fi;
  local i;
  for i in "$@"; do
    for each in ${i//\// }; do
      full+="/$each";
        \stat -c '%a %U:%G(%u:%g) %F %n' "$full";
        if [[ -f "$full" ]]; then
        sym="$(readlink -q ${full})";
        if [[ "${sym:=null}" == null ]]; then
          \lsattr "$full";
        else
          \lsattr "$sym";
        fi;
        unset sym;
      fi;
    done;
    printf "\n";
    unset full each;
  done;
};

function cpbak () {
  function _halp() {
    printf "Usage: cpbak [-bdhr] file\nIf no option is provided the default option is to backup\n\n";
    printf "  -b\tbackup file(s)\n";
    printf "  -d\tdiff file from backup\n";
    printf "  -h\tprint help\n";
    printf "  -r\trestore file from backup\n\n";
  };
  if [[ "$#" -eq 0 ]]; then
    _halp; 
  elif [[ "$@" =~ ^-[bdhr]{2} ]]; then
    printf "Multipe flags not supported!\n";
  elif [[ "$@" =~ ^-b ]] || ! [[ "$@" =~ ^-[bdhr] ]]; then
    local a i _list;
    for a in "$@"; do
      _list+=($a);
    done;
    for ((i=0; i<${#_list[@]}; i++)); do
      [[ "${_list[$i]}" =~ ^-b ]] && shift;
      if [ -d "${_list[$i]}" ]; then
        epoch="$(date +%s)"
        tar -zcf /root/cptechs/"$ticket"/"${epoch}${_list[$i]//\//_}".tar.gz "${_list[$i]}";
        { printf "%s -> " "${_list[$i]}"; printf "/root/cptechs/%s/" "$ticket"; printf "%s" "$epoch"; printf "%s.tar.gz\n" "${_list[$i]//\//_}"; } >&2;
      elif [ -f "${_list[$i]}" ]; then
        \cp -av "${_list[$i]}" /root/cptechs/"$ticket"/"$(date +%s)${_list[$i]//\//_}";
      fi;
    done;
  elif [[ "$@" =~ ^-d ]] && [[ "$#" -ge 2 ]]; then
    local _files _list _ans i e a;
    for a in "$@";do
      _list+=($a);
    done;
    for ((i=1; i<${#_list[@]}; i++)); do 
      if [[ -f "${_list[$i]}" ]]; then
        _files+=($(find /root/cptechs/${ticket} -regextype posix-extended -regex ".*/1[0-9]{7,}${_list[$i]//\//_}"));
        if [[ "${#_files[@]}" -eq 0 ]]; then
          printf "No backups found for %s\n" "${_list[$i]}";
        elif [[ "${#_files[@]}" -gt 5 ]]; then
          printf "Too many backup files found for %s\n" "${_list[$i]}";
        else
          for ((e=0; e<${#_files[@]}; e++)); do
            printf "%s) " "$e"; printf "%s\n" "${_files[$e]}";
          done;
          printf "\nPlease select a backup: ";
          read _ans;
          printf "\n";
          diff -u "${_list[$i]}" "${_files[$_ans]}";
          printf "\n";
        fi;
        unset _files;
      else
        printf "Sorry, you can't diff direcotry backups: %s\n" "${_list[$i]}";
      fi;
    done;
  elif [[ "$@" =~ ^-h ]]; then
    _halp;
  elif [[ "$@" =~ ^-r ]] && [[ "$#" -ge 2 ]]; then
    local _files _list _ans i e a;
    for a in "$@";do
      _list+=($a);
    done;
    for ((i=1; i<${#_list[@]}; i++)); do
      if [[ -f "${_list[$i]}" ]]; then
        _files+=($(find /root/cptechs/"${ticket}" -regextype posix-extended -regex ".*/1[0-9]{7,}${_list[$i]//\//_}"));
        if [[ "${#_files[@]}" -eq 0 ]]; then
          printf "No backups found for %s\n" "${_list[$i]}";
        elif [[ "${#_files[@]}" -gt 5 ]]; then
          printf "Too many backup files found for %s\n" "${_list[$i]}";
        else
          printf "Current: %s\n" "${_list[$i]}";
          for ((e=0; e<${#_files[@]}; e++)); do
            printf "%s) " "$e"; printf "%s\n" "${_files[$e]}";
          done;
          printf "\nPlease select a backup: ";
          read _ans;
          if [[ -f "${_files[$_ans]}" ]]; then
            printf "Overwriting %s " "${_list[$i]}"; printf "with %s\n" "${_files[$_ans]}";
            cat "${_files[$_ans]}" > "${_list[$i]}";
          else
            printf "Invalid option! %s\n" "${_files[$_ans]}";
          fi;
        fi;
        unset _files;
      else
        printf "Sorry, directories are not supported for restoration: %s\n" "${_list[$i]}";
      fi;
    done;
  fi;
  unset _halp _files _list _ans i e a;
};

function cplistips () {
  test -f /usr/local/cpanel/bin/whmapi1 || { >&2 printf "whmapi1 not found\n"; return; };
  /usr/local/cpanel/bin/whmapi1 listips|grep -oP "(?<=public_ip: )[^ ]+";
};

function cphostname () {
  test -f /usr/local/cpanel/bin/whmapi1 || { >&2 printf "whmapi1 not found\n"; return; };
  /usr/local/cpanel/bin/whmapi1 gethostname|grep -oP "(?<=hostname: )[^ ]+";
};

function cpns () {
  test -f /usr/local/cpanel/bin/whmapi1 || { >&2 printf "whmapi1 not found\n"; return; };
  /usr/local/cpanel/bin/whmapi1 get_nameserver_config|grep -oP "(?<= - )[^ ]+";
};

function exicwd () {
  if [ "$1" == "-a" ]; then
    zgrep -hoP "(?<=cwd=)/[^ ]+" /var/log/exim_mainlog*|sort|uniq -c|sort -nr;
  else
    grep -hoP "(?<=cwd=)/[^ ]+" /var/log/exim_mainlog|sort|uniq -c|sort -nr;
  fi;
};

function exilogins () {
  if [ "$1" == "-a" ]; then
    zgrep -ho "A=\(.*\)\(@\|+\)\(.*\) S=" /var/log/exim_mainlog*|sed 's/ S\=//g'|sed 's/A\=\(.*\)\://g'|sed '/\(.*\)P=\(.*\)/d'|sort|uniq -c|sort -nr;
  else
    grep -ho "A=\(.*\)\(@\|+\)\(.*\) S=" /var/log/exim_mainlog|sed 's/ S\=//g'|sed 's/A\=\(.*\)\://g'|sed '/\(.*\)P=\(.*\)/d'|sort|uniq -c|sort -nr;
  fi;
};

function vhostphp () {
  test -f /usr/local/cpanel/bin/whmapi1||{ >&2 printf "whmapi1 not found\n"; return; };
  test -f /etc/cpanel/ea4/is_ea4||{ >&2 printf "Not EA4\n"; return; };
  if [ "$#" -eq 0 ]; then
    /usr/local/cpanel/bin/whmapi1 php_get_vhost_versions|awk '/ +vhost:/{print $2,ver} {ver=$2}';
  else
    vhosts="$@";
    /usr/local/cpanel/bin/whmapi1 php_get_vhost_versions|awk '/ +vhost:/{print $2,ver} {ver=$2}'|grep -E "${vhosts// /|}";
  fi;
};

function cpdns () {
  local i;
  for i in "$@"; do
    >&2 printf "%s:\n" "$i";
    /usr/local/cpanel/3rdparty/perl/*/bin/perl -mCpanel::DnsRoots -e 'use Data::Dumper; print Dumper(Cpanel::DnsRoots->new()->get_ipv4_addresses_for_domain("@ARGV"));' "$i"|grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b";
  done;
};

function cpfpm () {
  local i;
  local j;
  local d;
  for i in /opt/cpanel/ea-php*; do
    find "$i" -path \*fpm.d\*.conf|\
    while read j; do
      d="$(basename $j)";
      printf "%s: " "${i##*/}"; printf "%s\n" "${d%.*}";
    done;
  done;
};

function ipinfo () {
  local i;
  for i in "$@"; do
    curl -s ipinfo.io/"$i"|sed -E '/^[{}]/d; s/([,"]*|^[ ]+)//g';
  done;
};

function hosted () {
  local i;
  local ip;
  for i in "$@"; do
    ips=($(dig A "$i" +short @8.8.8.8|grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b"));
    [ "${#ips[@]}" -eq 0 ] && {
    >&2 printf "%b" "$COL_YELLOW";
    >&2 printf "%s doesn't resolve\n" "$i";
    >&2 printf "%b" "$COL_RESET";
    return 2; };
    for ip in "${ips[@]}"; do
      org="$(ipinfo $ip|awk '/^org: /{print$3}')";
      [[ "$org" =~ Cloudflare ]] && {
      >&2 printf "%b" "$COL_YELLOW";
      >&2 printf "%s is behind Cloudflare\n" "$i";
      >&2 printf "%b" "$COL_RESET";
      return 2; };
      cplistips|grep -q "$ip";
      if [ "$?" -eq 0 ]; then
        >&2 printf "%b" "$COL_GREEN";
        >&2 printf "%s points to this server\n" "$i";
        >&2 printf "%b" "$COL_RESET";
        return 0;
      else
        >&2 printf "%b" "$COL_RED";
        >&2 printf "%s doesn't point to this server\n" "$i";
        >&2 printf "%b" "$COL_RESET";
        return 1;
      fi;
    done;
  done;
};

function cpssl () {
  function _halp () {
    >&2 printf "Usage: cpssl [options]...\n";
    >&2 printf "Provides tools and infomration about the AutoSSL queue.\n\n";
    >&2 printf "If no option is provided, a check will be performed against all orders in the queue\n";
    >&2 printf -- "  -c\t count orders in the queue\n";
    >&2 printf -- "  -d\t list domains from queue(excludes domains in SAN)\n";
    >&2 printf -- "  -D\t list domains from queue(includes domains in SAN)\n";
    >&2 printf -- "  -e\t list expired order id's\n";
    >&2 printf -- "  -E\t list expired order domains\n";
    >&2 printf -- "  -g\t check domains against Google Safe Browsing\n";
    >&2 printf -- "  -h\t prints this help statement\n";
    >&2 printf -- "  -o\t list order id's in queue\n";
    >&2 printf -- "  -p\t show AutoSSL provider\n";
    >&2 printf -- "  -r\t provide remote command for external request check\n\n";
  }
  function _menu () {
    if [[ "$#" -eq 0 ]]; then _main; else local OPTIND='1'; fi;
    while getopts "cdDeghopr" opt; do
      case "$opt" in
        c)
          python -m json.tool < /var/cpanel/autossl_queue_cpanel.json|grep -coP '(?<="order_item_id": ")[^"]+';
          ;;
        d)
          _args+='d';
          ;;
        D)_args+='D';
          ;;
        e)
          _args+='e';
          ;;
        E)
          _args+='E';
          ;;
        g)
          echo gsb;
          ;;
        h)
          _halp; 
          ;;
        o)
          _args+='o';
          ;;
        p)
          python -m json.tool /var/cpanel/autossl.json|grep -oP '(?<="provider": ")[^"]+'; 
          ;;
        r)
          echo remote requests
          ;;
        \?)
          >&2 printf -- "Invalid option: %s" "$OPTARG";
          ;;
      esac
    done;
  };
#  function _trap () {
#    unset _agent _code _count _count_day _count_hr _csr _curepoch _date _doc _domains _expepoch _host _ips _local_ip _orders _pass _pass_max _reqepoch _request _resolv _resp _san _uri _vendor;
#  };
#  function _list () { }
  function _resolve () {
    local _host="$1";
    local _resolv=($(dig A "$_host" +short @8.8.8.8|grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b"));
    if [[ "${#_resolv[@]}" -eq 0 ]]; then
      printf "%b" "$COL_RED";
      printf "(does not resolve): ";
      printf "%b" "$COL_RESET";
    else
      _local_ip='0';
      for _ip in "${_resolv[@]}"; do
        if [[ "${_ips[@]}" =~ "$_ip" ]]; then
          _local_ip='1';
          printf "%b" "$COL_GREEN";
          printf "(local %s): " "$_ip";
          printf "%b" "$COL_RESET";
          break;
        else
          printf "%b" "$COL_RED";
          printf "(remote %s): " "$_ip";
          printf "%b" "$COL_RESET";
          break;
        fi;
      done;
    fi;
  unset _resolv _host;
  };
  function _httpd_code () {
    local _code="$1";
    if [[ "$_code" -eq 200 ]]; then
      printf "%b" "$COL_GREEN"; printf "%s OK\n" "${_code#* }"; printf "%b" "$COL_RESET";
      return 0;
    elif [[ "$_code" -eq 301 ]]||[[ "$_code" -eq 302 ]]; then
      printf "%b" "$COL_YELLOW"; printf "%s Moved\n" "${_code#* }"; printf "%b" "$COL_RESET";
      return 1;
    elif [[ "$_code" -eq 403 ]]; then
      printf "%b" "$COL_RED";	printf "%s Forbidden\n" "${_code#* }"; printf "%b" "$COL_RESET";
      return 1;
    elif [[ "$_code" -eq 404 ]]; then
      printf "%b" "$COL_RED";	printf "%s Not Found\n" "${_code#* }"; printf "%b" "$COL_RESET";
      return 1;
    elif [[ "${_code:=null}" == null ]]; then
      printf "%b" "$COL_RED";	printf "empty response\n"; printf "%b" "$COL_RESET";
      return 1;
    else
      printf "%b" "$COL_RED";	printf "%s\n" "${_code#* }"; printf "%b" "$COL_RESET";
      return 1;
    fi;
    unset _code;
  };
  function _expire () {
    local _date="$@";
    local _reqepoch="$(date -u -d "$_date" +%s)";
    local _curepoch="$(date -u +%s)";
    local _expepoch="$((_reqepoch+604800))";
    local _count="$((_expepoch-_curepoch))";
    local _count_day="$((_count/3600/24))";
    local _count_hr="$((_count/3600%24))";
    if [[ "$_count" -lt 0 ]]; then
      _expired+=("${_domains[$i]}::${_orders[$i]}");
      printf "%bExpired on " "$COL_RED";
      printf "%s\n" "$(date -u -d @$_expepoch)";
      printf "%b" "$COL_RESET";
      return 1;
    elif [[ "$_count" -lt 172800 ]]; then
      printf "Expires in:%b " "$COL_YELLOW";
      printf "%s days " "$_count_day"; printf "%s hrs...\n" "$_count_hr";
      printf "%b" "$COL_RESET";
      return 0;
    else
      printf "Expires in:%b " "$COL_GREEN";
      printf "%s days " "$_count_day"; printf "%s hrs...\n" "$_count_hr";
      printf "%b" "$COL_RESET";
      return 0;
    fi;
    unset _date _reqepoch _curepoch _expepoch _count _count_day _count_hr;
  };
  function _main () {
    _vendor="$(python -m json.tool /var/cpanel/autossl.json|grep -oP '(?<="provider": ")[^"]+')";
    _domains=($(python -m json.tool < /var/cpanel/autossl_queue_cpanel.json|grep -oP '(?<=").+\..+(?=")'));
    _orders=($(python -m json.tool < /var/cpanel/autossl_queue_cpanel.json|grep -oP '(?<="order_item_id": ")[^"]+'));
    _request=($(python -m json.tool < /var/cpanel/autossl_queue_cpanel.json|grep -oP '(?<="request_time": ")[^"]+'));
    IFS=',';
    _csr=($(python -m json.tool < /var/cpanel/autossl_queue_cpanel.json|grep -oP '(?<=csr": ")[^"]+'|sed 's/\\n/\n/g; s/END CERTIFICATE REQUEST-----/END CERTIFICATE REQUEST-----,/g'));
    IFS=$'\n';
    _ips=($(/usr/local/cpanel/bin/whmapi1 listips|grep -oP '(?<=public_ip: )[^ ]+'));
    if [[ "$_vendor" =~ cPanel ]]; then _agent='COMODO DCV';fi;
    for ((i=0; i<${#_domains[@]}; i++)); do
      printf -- "--------------------\nchecking %s, " "${_domains[$i]}";
      printf "order: %s, " "${_orders[$i]}";
      _pass='0';
      _expire "${_request[$i]//[^0-9:-]/ }";
      [[ "$?" -eq 0 ]] && _pass="$((_pass+1))";
      _doc="$(grep -oP '(?<=^documentroot: )[^ ]+' /var/cpanel/userdata/*/${_domains[$i]} 2>/dev/null)";
      if [[ "${_doc:=null}" == null ]]; then
        printf "%b" "$COL_RED"; printf "Domain missing in userdata, removed?\n"; printf "%b" "$COL_RESET";
      else
        _uri="$(find $_doc ${_doc}/.well-known/pki-validation -maxdepth 1 -type f -regextype posix-extended -regex ".*[0-9A-Fa-f]{32}.txt" -printf '%T+ ' -exec basename '{}' \;|sort -r|awk 'NR==1{print$2}')";
        if [[ "${_uri:=null}" == null ]]; then
          _uri='abcdef0123456789ABCDEF0123456789.txt';
        else 
          _pass="$((_pass+1))";
        fi;
        _san=($(printf "%s" "${_csr[$i]}"|openssl req -noout -text|grep -oP '(?<=DNS:)[^, ]+'));
        for ((d=0; d<${#_san[@]}; d++)); do
          _pass_max="$((${#_san[@]}+1))";
          printf "%s/" "${_san[$d]}";
          if [[ "$_uri" == abcdef0123456789ABCDEF0123456789.txt ]]; then
            printf "%b" "$COL_RED"; printf "DCV file not found: "; printf "%b" "$COL_RESET";
          else
            printf "%s " "$_uri: ";
          fi;
          _resolve "${_san[$d]}";
          _resp="$(curl -sI -A "$_agent" -o /dev/null -m 7 -w "%{http_code}" "${_san[$d]}"/.well-known/pki-validation/"$_uri")";
          _httpd_code "$_resp";
          if [[ "$?" -eq 0 ]]; then
            _pass="$((_pass+1))";
          fi;
        done;
        if [[ "$_pass" -eq "$_pass_max" ]]; then
          _ready+=("${_domains[$i]}::${_orders[$i]}");
        fi;
        unset _san _pass _pass_max;
        if [[ -f "$_doc"/.htaccess ]]; then
          printf "%s/.htaccess: iThemes:" "$_doc";
          grep -qi "Begin.*iThemes" "$_doc"/.htaccess;
          if [[ "$?" -eq 0 ]]; then
            printf "%b" "$COL_RED";	printf "Yes "; printf "%b" "$COL_RESET";
          else
            printf "%b" "$COL_GREEN"; printf "No "; printf "%b" "$COL_RESET";
          fi;
          printf "AllinOneWPSecurity:";
          grep -qi "BEGIN All In One WP Security" "$_doc"/.htaccess;
          if [[ "$?" -eq 0 ]]; then
            printf "%b" "$COL_RED"; printf "Yes\n"; printf "%b" "$COL_RESET";
          else
            printf "%b" "$COL_GREEN"; printf "No\n"; printf "%b" "$COL_RESET";
          fi;
          awk '/comodo/{print "Line:",NR,"\t",$0;exit}' "$_doc"/.htaccess;
        else
          printf "%s/.htaccess: No such file or directory\n" "$_doc";
        fi;
      fi;
    done;
    printf "\n# Domains ready to restart DCV check:\n######################################\n";
    for ((i=0; i<${#_ready[@]}; i++)); do
      printf "%s\n" "${_ready[$i]}"|sed 's/::/ /';
    done;
    printf "\n# Expired requests that need removal:\n######################################\n";
    for ((i=0; i<${#_expired[@]}; i++)); do
      printf "%s\n" "${_expired[$i]}"|sed 's/::/ /';
    done;
    unset _expired _ready;
    printf "\n";
  };
  _menu "$@";
  unset _halp _menu _trap _list _resolve _httpd_code _expire _main;
};
